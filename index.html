<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Melbourne Modernist Art Generator</title>

  <!-- 8-bit arcade font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: #000000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: "Press Start 2P", system-ui, monospace;
      color: #f4f4f4;
    }

    .shell {
      max-width: 1120px;
      width: 100%;
      padding: 18px;
      background: #111111;
      border: 4px solid #3eff7a;
      box-shadow: 0 0 0 4px #000000, 0 0 24px #3eff7a55;
      display: grid;
      grid-template-columns: minmax(260px, 320px) minmax(420px, 700px);
      gap: 18px;
    }

    .label-head {
      margin-bottom: 8px;
      color: #3eff7a;
    }

    .label-head h1,
    .label-head h2 {
      font-size: 10px;
      line-height: 1.6;
    }

    .label-head h1 {
      letter-spacing: 0.12em;
    }

    .label-head h2 {
      letter-spacing: 0.16em;
    }

    .sprite-row {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin-top: 12px;
    }

    .sprite-img {
      width: 80px;
      image-rendering: pixelated;
      display: block;
      background: #FFFFFF;
      border: 3px solid #f4f4f4;
    }

    .dialogue {
      padding: 8px 10px;
      border-radius: 0;
      border: 3px solid #f4f4f4;
      background: #222222;
      font-size: 8px;
      line-height: 1.6;
      position: relative;
      max-width: 100%;
      white-space: pre-wrap;
      color: #f4f4f4;
    }

    .dialogue::before {
      content: "";
      position: absolute;
      left: -10px;
      top: 18px;
      width: 10px;
      height: 10px;
      background: #222222;
      border-left: 3px solid #f4f4f4;
      border-bottom: 3px solid #f4f4f4;
      transform: rotate(45deg);
    }

    .hint-small {
      font-size: 7px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      margin-top: 10px;
      color: #bbbbbb;
    }

    .canvas-wrap {
      text-align: center;
    }

    canvas {
      display: block;
      margin: 0 auto;
      background: #ffffff;
      border: 4px solid #f4f4f4;
      image-rendering: pixelated;
    }

    .btn-row {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
    }

    button {
      padding: 10px 18px;
      border-radius: 0;
      font-size: 8px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      cursor: pointer;
      border: 3px solid #f4f4f4;
    }

    #generateBtn {
      background: #3eff7a;
      color: #111111;
    }
    #generateBtn:hover {
      background: #9affb5;
    }

    #chaosBtn {
      background: #ff1744;
      color: #ffffff;
      box-shadow: 0 0 10px #ff174477;
    }
    #chaosBtn:hover {
      background: #ff617f;
    }

    .note {
      margin-top: 6px;
      font-size: 7px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: #bbbbbb;
    }

    @media (max-width: 900px) {
      .shell {
        grid-template-columns: 1fr;
      }
      .canvas-wrap {
        order: -1;
      }
      .btn-row {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>

  <!-- CLICK SOUNDS: update src to your actual files -->
  <audio id="clickMain" src="click-main.wav" preload="auto"></audio>
  <audio id="clickSoft" src="click-soft.wav" preload="auto"></audio>

  <div class="shell">
    <section class="wall-text">
      <div class="label-head">
        <h1>MELBOURNE MODERNIST</h1>
        <h2>ART GENERATOR // BOOTH E12</h2>
      </div>

      <div class="sprite-row">
        <img src="sprite.png" alt="Fair Director" class="sprite-img" />
        <div id="dialogueText" class="dialogue"></div>
      </div>

      <div class="hint-small">
        TIP: WHEN THE PANIC SETS IN, PRESS “ENTER THE STUDIO”.
      </div>
    </section>

    <section class="canvas-wrap">
      <canvas id="modernistCanvas" width="650" height="420"></canvas>
      <div class="btn-row">
        <button id="generateBtn">ENTER THE STUDIO</button>
        <button id="chaosBtn">DON'T PRESS THIS BUTTON</button>
      </div>
      <div class="note">
       
      </div>
    </section>
  </div>

  <script>
    const canvas = document.getElementById("modernistCanvas");
    const ctx = canvas.getContext("2d");
    const btn = document.getElementById("generateBtn");
    const chaosBtn = document.getElementById("chaosBtn");
    const dialogueEl = document.getElementById("dialogueText");

    // ---- AUDIO (Web Audio for BG, <audio> for clicks) ----
    const clickMain = document.getElementById("clickMain");
    const clickSoft = document.getElementById("clickSoft");

    let audioCtx = null;
    let musicGain = null;
    let musicStarted = false;

    function ensureAudioContext() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (!musicGain) {
        musicGain = audioCtx.createGain();
        musicGain.gain.value = 0;
        musicGain.connect(audioCtx.destination);
      }
    }

    function startMusic() {
      if (musicStarted) return;
      musicStarted = true;

      ensureAudioContext();
      startAmbientVoices();

      const now = audioCtx.currentTime;
      musicGain.gain.cancelScheduledValues(now);
      musicGain.gain.setValueAtTime(0, now);
      musicGain.gain.linearRampToValueAtTime(0.4, now + 8);
    }

    function playClickMain() {
      try {
        clickMain.currentTime = 0;
        clickMain.play();
      } catch (e) {}
    }

    function playClickSoft() {
      try {
        clickSoft.currentTime = 0;
        clickSoft.play();
      } catch (e) {}
    }

    const noteFreqs = [110.0, 130.81, 146.83, 164.81, 174.61, 196.0, 220.0];

    function choice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function randi(min, max) {
      return Math.floor(rand(min, max));
    }

    function startAmbientVoices() {
      if (!audioCtx || !musicGain) return;
      makeVoice(130.81, -8);
      makeVoice(98.0, 7);
    }

    function makeVoice(baseFreq, detune) {
      const osc = audioCtx.createOscillator();
      const filter = audioCtx.createBiquadFilter();
      const gain = audioCtx.createGain();

      osc.type = "square";
      osc.frequency.value = baseFreq;
      osc.detune.value = detune;

      filter.type = "lowpass";
      filter.frequency.value = 900;
      filter.Q.value = 8;

      gain.gain.value = 0.16;

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(musicGain);

      osc.start();

      function step() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const targetFreq = choice(noteFreqs) * (1 + (Math.random() - 0.5) * 0.06);
        const targetCutoff = rand(500, 2000);

        osc.frequency.linearRampToValueAtTime(targetFreq, t + rand(0.3, 1.2));
        filter.frequency.linearRampToValueAtTime(targetCutoff, t + rand(0.5, 1.5));

        const nextIn = rand(0.8, 2.4) * 1000;
        setTimeout(step, nextIn);
      }

      step();
    }

    // ---- TYPEWRITER ----
    const dialogueText = [
      "ALL ARTISTS ORIGINALLY BOOKED FOR THIS BOOTH HAVE PULLED OUT.",
      "FOR... REASONS.",
      "",
      "THE WALL TEXTS ARE PRINTED. THE CHAMPAGNE IS COLD.",
      "THE FAIR DIRECTOR IS STARTING TO PANIC.",
      "",
      "YOU ARE THE EMERGENCY ARTIST-IN-RESIDENCE.",
      "SLIP INTO THE STUDIO. KEEP IT POLITE.",
      "GENERATE ENDLESS HARD-EDGE MODERNIST ABSTRACTIONS,",
      "CONVINCING ENOUGH TO PASS, ANXIOUS ENOUGH TO FEEL REAL."
    ].join("\n");

    let dialogueIndex = 0;

    function typeDialogue() {
      if (dialogueIndex <= dialogueText.length) {
        const char = dialogueText[dialogueIndex];
        dialogueEl.textContent = dialogueText.slice(0, dialogueIndex);
        dialogueIndex++;

        if (char && char !== "\n" && char !== " ") {
          playClickSoft();
        }

        let delay = 18;
        if (char === "." || char === "—") delay = 120;
        if (char === "\n") delay = 80;
        setTimeout(typeDialogue, delay);
      }
    }

    // ---- PALETTES ----
    const palettes = [
      ["#f3eee3", "#b6493d", "#2c4b3f", "#e0b758", "#101010", "#3e3c47"],
      ["#f3eee3", "#c4523b", "#4b5f6b", "#d5b889", "#191919", "#5b463a"],
      ["#f3eee3", "#a73e3c", "#1f3e34", "#e1c177", "#111111", "#494860"]
    ];

    const chaosPalettes = [
      ["#f2eddc", "#111111", "#b10f2e", "#f5c453", "#224c6b", "#ffffff"],
      ["#f7f3e7", "#050505", "#d41c31", "#ffed4a", "#2b4f3a", "#fefefe"]
    ];

    // ---- “POLITE” MODERNIST GENERATOR ----
    function drawArt() {
      baseComposition({ chaos: false });
    }

    // ---- CHAOS GENERATOR ----
    function drawChaoticArt() {
      baseComposition({ chaos: true });
      // extra chaos “overpainting”
      addGesturalStrokes();
      addInkSplats();
      addHeavyNoise(0.18);
    }

    // shared base composition logic
    function baseComposition({ chaos }) {
      const w = canvas.width;
      const h = canvas.height;

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalAlpha = 1;
      ctx.clearRect(0, 0, w, h);

      const palette = chaos ? choice(chaosPalettes) : choice(palettes);
      const paper = palette[0];
      const inks = palette.slice(1);

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, w, h);

      const marginX = 70;
      const marginY = 50;
      const innerW = w - marginX * 2;
      const innerH = h - marginY * 2;

      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 4;
      ctx.strokeRect(marginX, marginY, innerW, innerH);

      ctx.fillStyle = paper;
      ctx.fillRect(marginX, marginY, innerW, innerH);

      const m = 6;
      const compX = marginX + m;
      const compY = marginY + m;
      const compW = innerW - m * 2;
      const compH = innerH - m * 2;

      addNoise(chaos ? 0.14 : 0.11);

      // underpaint
      ctx.save();
      ctx.translate(
        marginX + innerW / 2 + rand(-10, 10),
        marginY + innerH / 2 + rand(-10, 10)
      );
      ctx.rotate(rand(-5, 5) * Math.PI / 180);
      ctx.fillStyle = choice(inks);
      ctx.fillRect(-compW / 2, -compH / 2, compW, compH);
      ctx.restore();

      if (Math.random() < (chaos ? 0.9 : 0.7)) {
        ctx.save();
        ctx.translate(
          marginX + innerW / 2 + rand(-18, 18),
          marginY + innerH / 2 + rand(-18, 18)
        );
        ctx.rotate(rand(-10, 10) * Math.PI / 180);
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = choice(inks);
        ctx.fillRect(
          -compW * rand(0.4, 0.7),
          -compH * rand(0.4, 0.7),
          compW * rand(0.6, 1.0),
          compH * rand(0.6, 1.0)
        );
        ctx.restore();
        ctx.globalAlpha = 1;
      }

      ctx.save();
      ctx.translate(
        marginX + innerW / 2 + rand(-6, 6),
        marginY + innerH / 2 + rand(-6, 6)
      );
      ctx.rotate(rand(-4, 4) * Math.PI / 180);
      ctx.fillStyle = paper;
      ctx.fillRect(-compW * 0.42, -compH * 0.46, compW * 0.84, compH * 0.94);
      ctx.restore();

      const barCount = chaos ? randi(4, 8) : randi(6, 11);
      for (let i = 0; i < barCount; i++) {
        drawBar(compX, compY, compW, compH, inks);
      }

      if (Math.random() < (chaos ? 0.9 : 0.7)) {
        drawDiagonalSlab(compX, compY, compW, compH, inks, chaos);
      }

      const lineCount = chaos ? randi(10, 20) : randi(5, 11);
      for (let i = 0; i < lineCount; i++) {
        drawAnxiousLine(compX, compY, compW, compH, inks, chaos);
      }

      const voidCount = chaos ? randi(0, 3) : randi(1, 4);
      for (let i = 0; i < voidCount; i++) {
        drawVoid(compX, compY, compW, compH, paper, chaos);
      }

      const chipCount = randi(1, 5);
      for (let i = 0; i < chipCount; i++) {
        drawEdgeChip(marginX, marginY, innerW, innerH, inks);
      }

      if (!chaos && Math.random() < 0.6) {
        drawDisc(compX, compY, compW, compH, inks);
      }

      addVignette();
    }

    function drawBar(compX, compY, compW, compH, inks) {
      ctx.save();

      const color = choice(inks);
      const vertical = Math.random() < 0.45;
      const w = vertical
        ? rand(compW * 0.08, compW * 0.24)
        : rand(compW * 0.18, compW * 0.6);
      const h = vertical
        ? rand(compH * 0.18, compH * 0.5)
        : rand(compH * 0.08, compH * 0.24);

      let x = compX + rand(0, compW - w);
      let y = compY + rand(0, compH - h);

      const angle = rand(-12, 12) * Math.PI / 180;
      const cx = x + w / 2;
      const cy = y + h / 2;

      ctx.translate(cx, cy);
      ctx.rotate(angle);
      ctx.translate(-w / 2, -h / 2);

      if (Math.random() < 0.3) {
        ctx.fillStyle = "#f3eee3";
        ctx.fillRect(-3, -3, w + 6, h + 6);
      }

      ctx.fillStyle = color;
      ctx.fillRect(0, 0, w, h);

      const ticks = randi(1, 3);
      for (let i = 0; i < ticks; i++) {
        if (Math.random() < 0.8) {
          ctx.strokeStyle = "#111111";
          ctx.lineWidth = 0.7;
          ctx.beginPath();
          ctx.moveTo(rand(2, w - 2), rand(2, h - 2));
          ctx.lineTo(rand(2, w - 2), rand(2, h - 2));
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    function drawDiagonalSlab(compX, compY, compW, compH, inks, chaos) {
      ctx.save();
      const color = choice(inks);
      ctx.fillStyle = color;
      ctx.globalAlpha = chaos ? 0.95 : 0.85;

      const w = compW * rand(0.35, 0.9);
      const h = compH * rand(0.08, chaos ? 0.35 : 0.22);
      const x = compX + compW * rand(0.1, 0.5);
      const y = compY + compH * rand(0.1, 0.8);
      const angle = rand(-45, -10) * Math.PI / 180;

      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.fillRect(-w / 2, -h / 2, w, h);

      ctx.strokeStyle = "#101010";
      ctx.lineWidth = chaos ? 2 : 1.2;
      ctx.beginPath();
      ctx.moveTo(-w / 2 + rand(-4, 4), rand(-4, 4));
      ctx.lineTo(w / 2 + rand(-4, 4), rand(-4, 4));
      ctx.stroke();

      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawAnxiousLine(compX, compY, compW, compH, inks, chaos) {
      ctx.save();

      const color = Math.random() < 0.55 ? "#101010" : choice(inks);
      ctx.strokeStyle = color;
      ctx.lineWidth = chaos
        ? (Math.random() < 0.5 ? rand(2, 4) : rand(1, 2))
        : (Math.random() < 0.3 ? 0.9 : 1.4);

      const horizontal = Math.random() < 0.5;
      let x1, y1, x2, y2;

      if (horizontal) {
        y1 = y2 = compY + rand(compH * 0.05, compH * 0.95);
        x1 = compX + rand(-20, compW * 0.3);
        x2 = compX + compW - rand(-20, compW * 0.3);
      } else {
        x1 = x2 = compX + rand(compW * 0.05, compW * 0.95);
        y1 = compY + rand(-20, compH * 0.3);
        y2 = compY + compH - rand(-20, compH * 0.3);
      }

      const jitter = () => rand(chaos ? -6 : -3.1, chaos ? 6 : 3.1);

      ctx.beginPath();
      ctx.moveTo(x1 + jitter(), y1 + jitter());
      ctx.lineTo(x2 + jitter(), y2 + jitter());
      ctx.stroke();

      if (chaos && Math.random() < 0.2) {
        ctx.lineWidth *= 0.5;
        ctx.beginPath();
        ctx.moveTo(x1 + jitter(), y1 + jitter());
        ctx.lineTo(x2 + jitter(), y2 + jitter());
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawVoid(compX, compY, compW, compH, paper, chaos) {
      ctx.save();
      const w = compW * rand(0.06, chaos ? 0.35 : 0.2);
      const h = compH * rand(0.04, chaos ? 0.3 : 0.16);
      const x = compX + rand(0, compW - w);
      const y = compY + rand(0, compH - h);

      ctx.fillStyle = chaos
        ? (Math.random() < 0.4 ? "#000000" : paper)
        : (Math.random() < 0.7 ? paper : "#e9e2d6");
      ctx.fillRect(x, y, w, h);

      if (Math.random() < (chaos ? 0.7 : 0.5)) {
        ctx.strokeStyle = "#111111";
        ctx.lineWidth = chaos ? 1.2 : 0.7;
        ctx.strokeRect(x, y, w, h);
      }

      ctx.restore();
    }

    function drawDisc(compX, compY, compW, compH, inks) {
      ctx.save();
      const r = (compW + compH) / 2 * rand(0.04, 0.11);
      const cx = compX + rand(r, compW - r);
      const cy = compY + rand(r, compH - r);

      ctx.globalAlpha = 0.85;
      ctx.fillStyle = choice(inks);
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();

      if (Math.random() < 0.5) {
        ctx.globalAlpha = 1;
        ctx.strokeStyle = "#101010";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(cx + rand(-1, 1), cy + rand(-1, 1), r * rand(0.4, 0.8), 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function drawEdgeChip(marginX, marginY, innerW, innerH, inks) {
      ctx.save();
      const side = choice(["top", "bottom", "left", "right"]);
      const color = choice(inks);

      let x = 0, y = 0, w = 0, h = 0;
      const thickness = rand(3, 8);

      if (side === "top" || side === "bottom") {
        w = rand(innerW * 0.15, innerW * 0.7);
        h = thickness;
        x = marginX + rand(0, innerW - w);
        y = side === "top"
          ? marginY + rand(0, 6)
          : marginY + innerH - rand(0, 6) - h;
      } else {
        h = rand(innerH * 0.15, innerH * 0.7);
        w = thickness;
        y = marginY + rand(0, innerH - h);
        x = side === "left"
          ? marginX + rand(0, 6)
          : marginX + innerW - rand(0, 6) - w;
      }

      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);
      ctx.restore();
    }

    function addNoise(strength = 0.1) {
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        const n = (Math.random() - 0.5) * 40 * strength;
        data[i] += n;
        data[i + 1] += n;
        data[i + 2] += n;
      }
      ctx.putImageData(imgData, 0, 0);
    }

    function addHeavyNoise(strength = 0.2) {
      addNoise(strength);
    }

    function addVignette() {
      const grd = ctx.createRadialGradient(
        canvas.width / 2,
        canvas.height / 2,
        Math.min(canvas.width, canvas.height) * 0.3,
        canvas.width / 2,
        canvas.height / 2,
        Math.max(canvas.width, canvas.height) * 0.9
      );
      grd.addColorStop(0, "rgba(0,0,0,0)");
      grd.addColorStop(1, "rgba(0,0,0,0.26)");

      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // extra gestural strokes (Wols / Sonderborg / Mathieu vibes)
    function addGesturalStrokes() {
      const w = canvas.width;
      const h = canvas.height;

      const strokeCount = randi(6, 14);
      for (let i = 0; i < strokeCount; i++) {
        ctx.save();
        ctx.globalAlpha = rand(0.4, 0.9);
        ctx.strokeStyle = Math.random() < 0.6 ? "#000000" : "#ffffff";
        ctx.lineWidth = rand(2, 7);

        const cx = rand(w * 0.1, w * 0.9);
        const cy = rand(h * 0.1, h * 0.9);
        const radius = rand(40, 140);
        const angleStart = rand(0, Math.PI * 2);
        const angleEnd = angleStart + rand(Math.PI * 0.3, Math.PI * 1.4);

        ctx.beginPath();
        ctx.arc(cx, cy, radius, angleStart, angleEnd);
        ctx.stroke();
        ctx.restore();
      }
    }

    function addInkSplats() {
      const w = canvas.width;
      const h = canvas.height;

      const splatCount = randi(10, 25);
      for (let i = 0; i < splatCount; i++) {
        ctx.save();
        const x = rand(w * 0.1, w * 0.9);
        const y = rand(h * 0.1, h * 0.9);
        const r = rand(3, 12);
        ctx.globalAlpha = rand(0.4, 0.95);
        ctx.fillStyle = Math.random() < 0.7 ? "#000000" : "#ffffff";
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();

        // little spiky legs
        const legCount = randi(3, 7);
        for (let j = 0; j < legCount; j++) {
          const angle = rand(0, Math.PI * 2);
          const len = rand(8, 30);
          ctx.strokeStyle = ctx.fillStyle;
          ctx.lineWidth = rand(1, 3);
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(angle) * len, y + Math.sin(angle) * len);
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    // ---- INTERACTION ----
    btn.addEventListener("click", () => {
      startMusic();
      playClickMain();
      drawArt();
    });

    chaosBtn.addEventListener("click", () => {
      startMusic();
      playClickMain();
      drawChaoticArt();
    });

    window.addEventListener("keydown", () => {
      startMusic();
    });

    window.addEventListener("load", () => {
      typeDialogue();
      drawArt();
    });
  </script>
</body>
</html>

